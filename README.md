# About Encryption


## 为何要加密

> 将明文转化成密文，保护数据安全。

## 加密算法分类

### 对称加密
>常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。

>*加密和解密使用相同的密钥*

#### DES
* 介绍  
	>1.  输入：64位明文输入块
	>2.  输出：64位密文输出块
	>3.  密钥：64位密钥 （实际用到了56位，第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1）

* 过程

	* 初始置换    
	> 其功能是把输入的**64位数据块**按位重新组合，并把输出分为**L0、R0**两部分，每部分各长32位，其**置换规则为将输入的第58位换到第一位,第50位换到第2位……依此类推,最后一位是原来的第7位**。L0、R0则是换位输出后的两部分，L0是输出的左32位，R0是右32位

	>  **例** :设置换前的输入值为D1D2D3……D64,则经过初始置换后的结果为:L0=D58D50……D8;R0=D57D49……D7。

	> **其置换规则见下表**：
		>> 58,50,42,34,26,18,10,2,

		>>60,52,44,36,28,20,12,4,

		>>62,54,46,38,30,22,14,6,

		>>64,56,48,40,32,24,16,8,

		>>57,49,41,33,25,17,9,1,

		>>59,51,43,35,27,19,11,3,

		>>61,53,45,37,29,21,13,5,

		>>63,55,47,39,31,23,15,7,

	* 16轮相同的运算
		1. 加密过程
		>![](https://img-blog.csdn.net/20150319115656456?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFwcHlsZWU2Njg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

		2. 解密过程
		>![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0=baike92,5,5,92,30/sign=de44e957314e251ff6faecaac6efa272/e824b899a9014c08f17663c80b7b02087bf4f40a.jpg)

	* 逆置换
	> 经过 16 次迭代运算后，得到 L16、R16，将此作为输入，进行逆置换，逆置换正好是初始置换的逆运算，由此即得到密文输出。

### 非对称加密

#### 故事
比如，李四想给张三发送密文。
于是李四开始给张三发QQ

李四：
“hi哥们，我想给你发个密文，把你的公钥给我发过来用用。”

张三：
“没问题的，这是我的公钥： d#8yHE8eU#hb*!neb，用这个公钥加密你的信息后给我发过来吧”

李四：
“这是我想对你说的话： *&#@uehuu(**#eehu&$##bfeu&&”





>  RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。


>*加密和解密使用不同的密钥：公开密钥和私有密钥*

#### RSA

1. 加密
	> __密文__＝__明文__的__E__次方 mod **N**

	> 公钥＝(E,N)
2. 解密
	> __明文__＝__密文__的__D__次方 mod **N**

	> 私钥=（D,N）

3. 生成密钥对
	>数学依据：对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠

	#### 数学上的概念

	1. 互质关系

		```
		如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。

		关于互质关系，不难得到以下结论：

    　　1. 任意两个质数构成互质关系，比如13和61。

    　　2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3	和10。

    　　3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。

    　　4. 1和任意一个自然数是都是互质关系，比如1和99。

    　　5. p是大于1的整数，则p和p-1构成互质关系，比如57和56。

    　　6. p是大于1的奇数，则p和p-2构成互质关系，比如17和15。
		```

	2. 欧拉函数

		```
		请思考以下问题：

    　　任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）

		计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。

		φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。

		第一种情况

		如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。

		第二种情况

		如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。

		第三种情况

		如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则

		比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。

		这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、...、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。

		上面的式子还可以写成下面的形式：

		可以看出，上面的第二种情况是 k=1 时的特例。

		第四种情况

		如果n可以分解成两个互质的整数之积，

    　　n = p1 × p2

		则

    　　φ(n) = φ(p1p2) = φ(p1)φ(p2)

		即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。

		这一条的证明要用到"中国剩余定理"，这里就不展开了，只简单说一下思路：如果a与p1互质(a<p1)，b与p2互质(b<p2)，c与p1p2互质(c<p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。

		第五种情况

		因为任意一个大于1的正整数，都可以写成一系列质数的积。

		根据第4条的结论，得到

		再根据第3条的结论，得到

		也就等于

		这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：
		```

	3. 欧拉定理

		```
			欧拉函数的用处，在于欧拉定理。"欧拉定理"指的是：
	    	如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：
			也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。
			欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。
			欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，
			已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。
			因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。
			欧拉定理有一个特殊情况。
	    	假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成
			这就是著名的费马小定理。它是欧拉定理的特例。
			欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。

		```

	4. 模反元素
		```
	    如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。

	    这时，b就叫做a的"模反元素"。
			比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {...,-18,-7,4,15,26,...}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。

			欧拉定理可以用来证明模反元素必然存在。

			可以看到，a的 φ(n)-1 次方，就是a的模反元素。
		```

#### 生成步骤

1. 第一步，随机选择两个不相等的质数p和q。

	>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）

2. 第二步，计算p和q的乘积n。

	>爱丽丝就把61和53相乘。
	>　n = 61×53 = 3233

	>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。

3. 第三步，计算n的欧拉函数φ(n)。

	> 根据公式：

	>　　φ(n) = (p-1)(q-1)

	>爱丽丝算出φ(3233)等于60×52，即3120。

4. 第四步，随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质。

	>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）

5. 第五步，计算e对于φ(n)的模反元素d。
	> 所谓"模反元素"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。

	> ed ≡ 1 (mod φ(n))

	> 这个式子等价于

 >　ed - 1 = kφ(n)

	>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。

  >　ex + φ(n)y = 1

	>已知 e=17, φ(n)=3120，

 >　17x + 3120y = 1

	>这个方程可以用"扩展欧几里得算法"求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。

	>至此所有计算完成。

6. 第六步，将n和e封装成公钥，n和d封装成私钥。


## OSI模型  
	1. 应用层
		(QQ，钉钉，HTTP，HTTPS)
	2. 传输层
		(TCP，UDP)
	3. 网络层
		(IPv4,IPv6)
	4. 数据链路层
		...
	5. 物理层
		...

	A(应用层-传输层-网络层----物理层)  -->  B（物理层-数据链路层-网络层---应用层）

### TLS/SSL

```
SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和ＳＳＬ握手协议。

TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

	 	－－－－－－－－－
　　　　| HTTP |
　　　　－－－－－－－－－
　　　　| SSL |
　　　　－－－－－－－－－
　　　　| TCP |
　　　　－－－－－－－－－
　　　　| IP |
　　　　－－－－－－－－－
　　　　
　　　　如果利用SSL协议来访问网页，其步骤如下：
　　　　用户：在浏览器的地址栏里输入https://www.sslserver.com
　　HTTP层：将用户需求翻译成HTTP请求，如
　　GET /index.htm HTTP/1.1
　　Host http://www.sslserver.com
　　SSL层: 借助下层协议的的信道安全的协商出一份加密密钥，并用此密钥来加密HTTP请求。
　　TCP层：与web server的443端口建立连接，传递SSL处理后的数据。
　　接收端与此过程相反。
```
![](https://images.cnitblog.com/kb/1/201401/05125746-760ce000eb624a4f9a7d0d1d0b71ec0a.png)


## HTTP & HTTPS

![](https://sfault-image.b0.upaiyun.com/246/674/2466740314-58ec51ac06bb1_articlex)

### 办法1
张三：四儿，接好了，这是我的公钥：fewfeef#￥#@#@#R###。

李四：三哥，别急嘛，12345？

张三：上山打老虎！

李四：欧了，这是我想对你说的话：$IJ4#(##(#(！

张三：好，讲究！

---
黑客小刘：四儿，上次那个公钥我不用了，这是我的新公钥：#￥#@#3@223#53R2#5##。

李四：哦.......12345?

黑客小刘：哎，你还不相信你三哥？上山打老虎！

李四：哈哈，三哥你看看这个计划如何？2g3n&&$@#(#@)

黑客小刘：很好（邪恶的笑)

李四：...


### 办法2

黑客小刘：四儿，最近有什么新计划没？。

李四：没。。。有。。。。

黑客小刘：没有？我是你三哥，你说吧。

李四：那你先把你的证书给我看看？

黑客小刘：....神马证...书..？上山打老虎！

--- 李四已下线 ---

---

原来，李四自从上次被坑了之后私下里去找了一个叫“王五”的大哥，想寻求帮助，王五说这个事不难，王五对李四说：“如果你相信我，那么我就来作证人证明张三是张三”。

李四说：“那没问题，那你怎么证明张三是他本人？”。
“我可以给张三颁发一个证书！只要他给你看到这个证书，你就相信他是张三”，王五说。
李四思考了片刻又问道：“那我怎么证明这个证书不是伪造的呢？”
王五说：“因为我可以给你一个神器，这个神器能够让你分辨这个证书确实是我颁发的！”。
“哇！这么吊！那快给我！”，李四渴望的眼神中又闪烁着对王五的崇拜！

其实，这个神奇呢，很简单，你想到了吗？嗯，于是，王五就把这个神器交给了李四，这个神器是：“王五的公钥”！。

---

原来，王五的签名不是普通的签名，也不是像公证处那种普通的盖章，而是“电子签名”！因为王五他也有自己的一对“私/公钥”，所以他把张三的“个人信息”以及“公钥信息”用他的私钥加密成“密文”，把这个密文当做“电子签名”签在了证书上，然后这个证书就被称为“电子证书”，最后再把自己的公钥送给了李四，那么李四收到张三给的证书之后，就可以利用王五给的公钥进行解密证书上面的签名，因为证书上的签名是用王五私钥加的密，所以相应的，也只能用王五的公钥进行解密，李四最后将解密出来的公钥信息和收到的公钥信息进行比对，如果信息一致，就证明了两个问题：

    张三确实是张三
    张三的公钥确实来自张三且没被修改过

最后的最后，因为在这里“王五”的神器(公钥)太关键，它能够决定其他人的证书是否真实有效，所以我们把“王五”的公钥叫做“根证书”！


## 电子签名  
电子签名 [1]  是指数据电文中以电子形式所含、所附用于识别签名人身份并表明签名人认可其中内容的数据。通俗点说，电子签名就是通过密码技术对电子文档的电子形式的签名


## 电子证书  
电子证书（Digital Certificate）又称为数字证书或数位证书，是一种用于电脑的身份识别机制。电子证书是一个或一组电脑档案，内载拥有人的身份资料及一组公开密码匙。凭著电子证书档案，拥有人可向电脑系统认证自己的身份，从而存取或使用某一特定的电脑服务。


## 跟证书  
根证书是CA认证中心给自己颁发的证书,是信任链的起始点。安装根证书意味着对这个CA认证中心的信任。


## MD5

## 抓包  

## Other
1. 密钥直接明文存在sharedprefs文件中，这是最不安全的。
2. 密钥直接硬编码在Java代码中，这很不安全，dex文件很容易被逆向成java代码。
3. 将密钥分成不同的几段，有的存储在文件中、有的存储在代码中，最后将他们拼接起来，可以将整个操作写的很复杂，这因为还是在java层，逆向者只要花点时间，也很容易被逆向。
4. 用ndk开发，将密钥放在so文件，加密解密操作都在so文件里，这从一定程度上提高了的安全性，挡住了一些逆向者，但是有经验的逆向者还是会使用IDA破解的。
5. 在so文件中不存储密钥，so文件中对密钥进行加解密操作，将密钥加密后的密钥命名为其他普通文件，存放在assets目录下或者其他目录下，接着在so文件里面添加无关代码（花指令），虽然可以增加静态分析难度，但是可以使用动态调式的方法，追踪加密解密函数，也可以查找到密钥内容。
